<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Concurrent Programming and Synchronization | Alicia&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="使用多线程时，要注意防止不同线程意外修改数据的问题，下面总结一下常用的同步方式。
原子操作原子操作是同步的一个简单的形式，它处理简单的数据类型。其优势是不妨碍竞争的线程。对于简单操作，比如递增一个计数器，原子操作比使用锁具有更高的性能优势。 
void retain() {
    OSAtomicIncrement64(&amp;amp;retainCount);    // retainCount 为">
<meta property="og:type" content="article">
<meta property="og:title" content="Concurrent Programming and Synchronization">
<meta property="og:url" content="http://yoursite.com/2016/06/24/Concurrent-Programming-and-Synchronization/index.html">
<meta property="og:site_name" content="Alicia's Blog">
<meta property="og:description" content="使用多线程时，要注意防止不同线程意外修改数据的问题，下面总结一下常用的同步方式。
原子操作原子操作是同步的一个简单的形式，它处理简单的数据类型。其优势是不妨碍竞争的线程。对于简单操作，比如递增一个计数器，原子操作比使用锁具有更高的性能优势。 
void retain() {
    OSAtomicIncrement64(&amp;amp;retainCount);    // retainCount 为">
<meta property="og:updated_time" content="2016-06-25T01:21:45.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Concurrent Programming and Synchronization">
<meta name="twitter:description" content="使用多线程时，要注意防止不同线程意外修改数据的问题，下面总结一下常用的同步方式。
原子操作原子操作是同步的一个简单的形式，它处理简单的数据类型。其优势是不妨碍竞争的线程。对于简单操作，比如递增一个计数器，原子操作比使用锁具有更高的性能优势。 
void retain() {
    OSAtomicIncrement64(&amp;amp;retainCount);    // retainCount 为">
  
    <link rel="alternative" href="/atom.xml" title="Alicia&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
  
<!-- Baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?cbbd9aa76d6f5e7b8019ca96dba4e7e2";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>
<!-- End Baidu Analytics -->


</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/images/avatar.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Alicia Ly</a></h1>
		</hgroup>

		
		<p class="header-subtitle">［LEAF Photo］作者</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/alicialy" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/2027344411/" title="weibo">weibo</a>
					        
								<a class="mail" target="_blank" href="mailto:alicialy@qq.com" title="mail">mail</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/Debug/" style="font-size: 16.67px;">Debug</a> <a href="/tags/Mac/" style="font-size: 10px;">Mac</a> <a href="/tags/Tools/" style="font-size: 13.33px;">Tools</a> <a href="/tags/iOS/" style="font-size: 20px;">iOS</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">独立开发者，目前正在开发一款拼图类应用 [LEAF Photo]，已上架。</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Alicia Ly</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
			
				<img lazy-src="/images/avatar.jpg" class="js-avatar">
			
			</div>
			<hgroup>
			  <h1 class="header-author">Alicia Ly</h1>
			</hgroup>
			
			<p class="header-subtitle">［LEAF Photo］作者</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/alicialy" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/2027344411/" title="weibo">weibo</a>
			        
						<a class="mail" target="_blank" href="mailto:alicialy@qq.com" title="mail">mail</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap"><article id="post-Concurrent-Programming-and-Synchronization" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2016/06/24/Concurrent-Programming-and-Synchronization/" class="article-date">
  	<time datetime="2016-06-24T01:26:35.000Z" itemprop="datePublished">2016-06-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Concurrent Programming and Synchronization
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/iOS/">iOS</a></li></ul>
	</div>

        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>使用多线程时，要注意防止不同线程意外修改数据的问题，下面总结一下常用的同步方式。</p>
<h2 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h2><p>原子操作是同步的一个简单的形式，它处理简单的数据类型。其优势是不妨碍竞争的线程。对于简单操作，比如递增一个计数器，原子操作比使用锁具有更高的性能优势。 </p>
<pre><code>void retain() {
    OSAtomicIncrement64(&amp;retainCount);    // retainCount 为实例变量，相当于 retainCount++
}
void release() {
    unit32_t originalValue;
    orginalValue = OSAtomicDecrement64(&amp;retainCount); // 相当于 retainCount--
    if (originalValue == 1) {
        this-&gt;free();
    }
}
</code></pre><p>查看支持原子操作的列表，参阅/user/include/libkern/OSAtomic.h头文件和参见 <a href="https://developer.apple.com/library/ios/documentation/System/Conceptual/ManPages_iPhoneOS/man3/OSAtomicTestAndSet.3.html" target="_blank" rel="external">atomic主页</a>。</p>
<h2 id="内存屏障（Memory-Barrier）"><a href="#内存屏障（Memory-Barrier）" class="headerlink" title="内存屏障（Memory Barrier）"></a>内存屏障（Memory Barrier）</h2><p>内存屏障（Memory Barrier）是用来确保内存操作按照正确顺序工作的非阻塞同步工具。内存屏障的作用就像一个栅栏，迫使处理器来完成位于障碍前面的任何加载和存储操作，才允许它执行位于屏障之后的加载和存储操作。</p>
<p>Volatile 变量适用于独立变量的另一个内存限制类型。编译器优化代码通过加载这些变量的值进入寄存器。对于本地变量，这通常不会有什么问题。但是如果一个变量对另外一个线程可见，那么这种优化可能会阻止其他线程发现变量的任何变化。在变量之前加上关键字 volatile 可以强制编译器每次使用变量的时候都从内存里面加载。如果一个变量的值随时可能给编译器无法检测的外部源更改，那么你可以把该变量声明为volatile变量。</p>
<p>因为内存屏障和volatile变量降低了编译器可执行的优化，因此应该谨慎使用它们，只在有需要的地方时候，以确保正确性。关于更多使用内存屏障的信息，参阅 OSMemoryBarrier 主页。</p>
<pre><code>// ...
OSMemoryBarrier();
// ...
</code></pre><h2 id="锁-互斥锁"><a href="#锁-互斥锁" class="headerlink" title="锁 - 互斥锁"></a>锁 - 互斥锁</h2><p>被这个锁保护的临界区只允许一个线程进入，其他线程如果没有获取得到锁权限，只能等待</p>
<h3 id="POSIX-互斥锁在很多程序里面很容易使用"><a href="#POSIX-互斥锁在很多程序里面很容易使用" class="headerlink" title="POSIX 互斥锁在很多程序里面很容易使用"></a>POSIX 互斥锁在很多程序里面很容易使用</h3><pre><code>pthread_mutex_t mutex;
void MyInitFunction() {
    pthread_mutex_init(&amp;mutex, NULL);
}

void MyLockingFunction() {
    pthread_mutex_lock(&amp;mutex);
    // do something ...
    pthread_mutex_unlock(&amp;mutex);
}
</code></pre><h3 id="NSLock-中实现了一个简单的互斥锁"><a href="#NSLock-中实现了一个简单的互斥锁" class="headerlink" title="NSLock 中实现了一个简单的互斥锁"></a>NSLock 中实现了一个简单的互斥锁</h3><pre><code>NSLock *theLock = [[NSLock alloc] init];
if ([theLock lock]) {
    // do something ...
    [theLock unlock];
}
</code></pre><p>除了标准的锁行为，NSLock 类还增加了 tryLock 和 lockBeforeDate: 方法。方法 tryLock 试图获取一个锁，但是如果锁不可用的时候，它不会阻塞线程。相反，它只是返回 NO。而 lockBeforeDate: 方法试图获取一个锁，但是如果锁没有在规定的时间内被获得，它会让线程从阻塞状态变为非阻塞状态（或者返回 NO ）。</p>
<a id="more"></a>
<pre><code>BOOL moreToDo = YES;
NSLock *theLock = [[NSLock alloc] init];
// ...
while (moreToDo) {
    // do another increment of calculation, until there’s no more to do.
    if ([theLock tryLock]) {
        // do something ...
        [theLock unlock];
    }
}
</code></pre><h3 id="synchronized-指令"><a href="#synchronized-指令" class="headerlink" title="@synchronized 指令"></a>@synchronized 指令</h3><p>@synchronized 是也创建一个互斥锁非常方便的方法。作为一种预防措施，@synchronized 块隐式的添加一个异常处理例程来保护代码。该处理例程会在异常抛出的时候自动的释放互斥锁。这意味着为了使用@synchronized指令，你必须在你的代码中启用异常处理。了如果你不想让隐式的异常处理例程带来额外的开销，你应该考虑使用锁的类。</p>
<pre><code>- (void)myMethod:(id)anObj {
    @synchronized(anObj) {
        // Everything between the braces is protected by the @synchronized directive.
    }
}
</code></pre><h3 id="NSConditionLock-对象"><a href="#NSConditionLock-对象" class="headerlink" title="NSConditionLock 对象"></a>NSConditionLock 对象</h3><p>它定义了一个互斥锁，可以使用特定值来锁住和解锁。不要把该类型的锁和条件（参见“条件”部分）混淆了。它的行为和条件有点类似，但是它们的实现非常不同。</p>
<p>通常，当多线程需要以特定的顺序来执行任务的时候，你可以使用一个 NSConditionLock 对象，比如当一个线程生产数据，而另外一个线程消费数据。生产者执行时，消费者使用由你程序指定的条件来获取锁（条件本身是一个你定义的整形值）。当生产者完成时，它会解锁该锁并设置锁的条件为合适的整形值来唤醒消费者线程，之后消费线程继续处理数据。</p>
<p>NSConditionLock 的锁住和解锁方法可以任意组合使用。比如，你可以使用 unlockWithCondition: 和 lock 消息，或使用 lockWhenCondition: 和 unlock 消息。当然，后面的组合可以解锁一个锁但是可能没有释放任何等待某特定条件值的线程。</p>
<pre><code>// Common
id condLock = [[NSConditionLock alloc] initWithCondition:NO_DATA];

// Thread A，生产者
while(true) {
    [condLock lockWhenCondition:NO_DATA];
    // 生产数据
    [condLock unlockWithCondition:HAS_DATA];
}

// Thread B，消费者
while (true) {
    [condLock lockWhenCondition:HAS_DATA
    //消费
    [condLock unlockWithCondition:NO_DATA];
}
</code></pre><h2 id="锁-递归锁"><a href="#锁-递归锁" class="headerlink" title="锁 - 递归锁"></a>锁 - 递归锁</h2><p>NSRecursiveLock 类定义的锁可以在同一线程多次获得，而不会造成死锁。一个递归锁会跟踪它被多少次成功获得了。每次成功的获得该锁都必须平衡调用锁住和解锁的操作。只有所有的锁住和解锁操作都平衡的时候，锁才真正被释放给其他线程获得。</p>
<p>正如它名字所言，这种类型的锁通常被用在一个递归函数里面来防止递归造成阻塞线程。你可以类似的在非递归的情况下使用他来调用函数，这些函数的语义要求它们使用锁。以下是一个简单递归函数，它在递归中获取锁。如果你不在该代码里使用 NSRecursiveLock 对象，当函数被再次调用的时候线程将会出现死锁。</p>
<pre><code>NSRecursiveLock *theLock = [[NSRecursiveLock alloc] init];

void MyRecursiveFunction(int value) {
    [theLock lock];
    if (value != 0) {
        --value;
        MyRecursiveFunction(value);
    }
    [theLock unlock];
}

MyRecursiveFunction(5);
</code></pre><h2 id="锁-读写锁"><a href="#锁-读写锁" class="headerlink" title="锁 - 读写锁"></a>锁 - 读写锁</h2><p>// TODO: 待完善… </p>
<h2 id="锁-分布锁"><a href="#锁-分布锁" class="headerlink" title="锁 - 分布锁"></a>锁 - 分布锁</h2><p>NSDistributedLock 分布锁，文件方式实现，可以跨进程用 tryLock 方法获取锁。用 unlock方 法释放锁。</p>
<p>NSDistributedLock 类可以被多台主机上的多个应用程序使用来限制对某些共享资源的访问，比如一个文件。锁本身是一个高效的互斥锁，它使用文件系统项目来实现，比如一个文件或目录。对于一个可用的NSDistributedLock对象，锁必须由所有使用它的程序写入。这通常意味着把它放在文件系统，该文件系统可以被所有运行在计算机上面的应用程序访问。</p>
<p>不像其他类型的锁，NSDistributedLock 并没有实现 NSLocking 协议，所有它没有lock 方法。一个 lock 方法将会阻塞线程的执行，并要求系统以预定的速度轮询锁。以其在你的代码中实现这种约束，NSDistributedLock 提供了一个 tryLock 方法，并让你决定是否轮询。</p>
<p>因为它使用文件系统来实现，一个 NSDistributedLock 对象不会被释放除非它的拥有者显式的释放它。如果你的程序在用户一个分布锁的时候崩溃了，其他客户端简无法访问该受保护的资源。在这种情况下，你可以使用 breadLock 方法来打破现存的锁以便你可以获取它。但是通常应该避免打破锁，除非你确定拥有进程已经死亡并不可能再释放该锁。</p>
<p>和其他类型的锁一样，当你使用 NSDistributedLock 对象时，你可以通过调用 unlock 方法来释放它。</p>
<h2 id="锁-自旋锁"><a href="#锁-自旋锁" class="headerlink" title="锁 -  自旋锁"></a>锁 -  自旋锁</h2><p>自旋锁：当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会一直等待（不会睡眠），当上一个线程的任务执行完毕，下一个线程会立即执行。</p>
<p>互斥锁：当上一个线程的任务没有执行完毕的时候（被锁住），那么下一个线程会进入睡眠状态等待任务执行完毕，当上一个线程的任务执行完毕，下一个线程会自动唤醒然后执行任务。</p>
<p>自旋锁在被锁后，下一个线程会一直等待上一个线程执行完毕，互斥锁则会进入睡眠状态等待。因为自旋不会引起调用者睡眠，所以效率高于互斥锁，它适合不耗时的操作，否则他一直占用CPU使CPU效率降低。</p>
<pre><code>OSSpinLock spinlock = OS_SPINLOCK_INIT;  
OSSpinLockLock(&amp;spinlock);  
// do something ...
OSSpinLockUnlock(&amp;spinlock);  
</code></pre><h2 id="锁-双重检查锁"><a href="#锁-双重检查锁" class="headerlink" title="锁 - 双重检查锁"></a>锁 - 双重检查锁</h2><p>// TODO: 待完善… </p>
<h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>GCD提供一种信号的机制，使用它我们可以创建“锁”，这个地方加引号是因为它不是锁。</p>
<p>我们把信号量当作是一个计数器，dispatch_semaphore_wait 等待信号，当信号总量为 0 时则一直等待，否则就可以正常的执行，并让信号总量 -1；dispatch_semaphore_signal 是发送一个信号，让信号总量加 1。</p>
<pre><code>// 实例类person
Person *person = [[Person alloc] init];
// 创建并设置信号量
dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);
// 线程A
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [person personA];
    [NSThread sleepForTimeInterval:5];
    dispatch_semaphore_signal(semaphore);
});

// 线程B
dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
    dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER);
    [person personB];
    dispatch_semaphore_signal(semaphore);
});
</code></pre><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>条件是信号量的另外一个形式，它允许在条件为真的时候线程间互相发送信号。</p>
<p>事件队列可能使用条件变量来给等待线程发送信号，此时它们在事件队列中的时候。如果一个事件到达时，队列将给条件发送合适信号。如果一个线程已经处于等待，它会被唤醒，届时它将会取出事件并处理它。如果两个事件到达队列的时间大致相同，队列将会发送两次信号唤醒两个线程。</p>
<h3 id="条件-使用-NSCondition-类"><a href="#条件-使用-NSCondition-类" class="headerlink" title="条件 - 使用 NSCondition 类"></a>条件 - 使用 NSCondition 类</h3><pre><code>// Thread A，为等待一个 NSCondition 对象的事件序列。
// cocaoCondition 变量包含了一个 NSCondition 对象
[cocoaCondition lock];
// timeToDoWork 变量是一个整形，它在其他线程里面发送条件信号时立即递增。
while (timeToDoWork &lt;= 0) { 
    [cocoaCondition wait];
}
timeToDoWork--;
// do some real work here ...
[cocoaCondition unlock];

// Thread B，条件发送信号代码，并递增他断言变量。你应该在给它发送信号前锁住条件。
[cocoaCondition lock];
timeToDoWork++;
[cocoaCondition signal];
[cocoaCondition unlock];
</code></pre><h3 id="条件-使用-POSIX-条件"><a href="#条件-使用-POSIX-条件" class="headerlink" title="条件 - 使用 POSIX 条件"></a>条件 - 使用 POSIX 条件</h3><pre><code>pthread_mutex_t mutex;
pthread_cond_t condition;
Boolean     ready_to_go = true;
void MyCondInitFunction() {
    pthread_mutex_init(&amp;mutex);
    pthread_cond_init(&amp;condition, NULL);
}

// Thread A
void MyWaitOnConditionFunction() {
    // Lock the mutex.
    pthread_mutex_lock(&amp;mutex); 
    // If the predicate is already set, then the while loop is bypassed;
    // otherwise, the thread sleeps until the predicate is set.
    while(ready_to_go == false) {
        pthread_cond_wait(&amp;condition, &amp;mutex);
    } 
    // Do work. (The mutex should stay locked.)
    // Reset the predicate and release the mutex.
    ready_to_go = false;
    pthread_mutex_unlock(&amp;mutex);
}

// Thread B
void SignalThreadUsingCondition() {
    // At this point, there should be work for the other thread to do.
    pthread_mutex_lock(&amp;mutex);
    ready_to_go = true; 
    // Signal the other thread to begin work.
    pthread_cond_signal(&amp;condition);
    pthread_mutex_unlock(&amp;mutex);
}
</code></pre><h2 id="执行-Selector"><a href="#执行-Selector" class="headerlink" title="执行 Selector"></a>执行 Selector</h2><p>NSObject 类声明了方法可以在应用的一个活动线程上面执行 selector 的方法。这些方法允许你的线程以异步的方式来传递消息，以确保它们在同一个线程上面执行是同步的。</p>
<p>在《Effective Objective-C 2.0》第 42 条指出多用 GCD，少用 performSelector 系列方法。</p>
<pre><code>[self performSelectorOnMainThread:@selector(doSomething) withObject:nil waitUntialDone:NO];

dispatch_async(dispatch_get_main_queue(), ^{
    [self doSomething];
});
</code></pre><h2 id="同步的性能"><a href="#同步的性能" class="headerlink" title="同步的性能"></a>同步的性能</h2><p>同步可以确保你的程序正确执行，但是可能会牺牲掉部分性能。如果发生锁的争夺，你的线程有可能进入阻塞，在体验上会产生更大的迟延。</p>
<p>参考下 <a href="http://perpendiculo.us/2009/09/synchronized-nslock-pthread-osspinlock-showdown-done-right/" target="_blank" rel="external">Benchmark Demo</a>，对比几种锁在加锁和解锁 33554432 次 (即 1024<em>1024</em>32)，耗时时间分别是<br>NSLock: 3.5175 sec<br>NSLock+IMP Cache: 3.1165 sec<br>pthread_mutex: 1.5870 sec<br>OSSpinLock: 1.0893<br>@synchronized: 9.9488 sec</p>
<ul>
<li>NSLock 和 NSLock+IMP 时间比较接近，他们都是 pthread mutexes 封装的，创建对象时需要额外开销</li>
<li>pthread_mutex C 语言中的互斥锁，性能较高，且较安全</li>
<li>OSSpinLock 自旋锁占用时间最少</li>
<li>@synchronized 内部会创建异常捕获的 handler 和其他内部使用的锁，所以消耗时间最长</li>
</ul>
<p>也可以参考下 ibireme (郭曜源) 的 <a href="https://github.com/ibireme/tmp/tree/master/iOSLockBenckmark/iOSLockBenckmark" target="_blank" rel="external">Benchmark Demo</a>。同时 ibireme 指出 <a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">OSSPinLock 不再安全</a>，所以看他的源码基本上是用 pthread_mutex 的情况比较多。</p>
<p>另外，在《Effective Objective-C 2.0》第 41 条指出应当多用派发队列，少用同步锁。即使用”串行同步队列” 或者 GCD 的 dispatch_barrier_async / dispatch_barrier_sync 来避开同步锁的使用。</p>
<h2 id="参考内容"><a href="#参考内容" class="headerlink" title="参考内容"></a>参考内容</h2><p><a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html" target="_blank" rel="external">iOS 多线程之线程安全</a><br><a href="http://www.dreamingwish.com/article/the-ios-multithreaded-programming-guide-4-thread-synchronization.html" target="_blank" rel="external">iOS 多线程编程指南之线程同步</a><br><a href="http://perpendiculo.us/2009/09/synchronized-nslock-pthread-osspinlock-showdown-done-right/" target="_blank" rel="external">Synchronized NSLock pthread OSSpinLock 的正确使用</a><br><a href="http://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">不再安全的 OSSpinLock</a></p>

      
    </div>
    
  </div>
  
  
    
<!-- 添加捐赠图标 -->
   <div class ="post-donate">
    <div id="donate_board" class="donate_bar center">
        <a id="btn_donate" class="btn_donate" href="javascript:;" title="打赏"></a>
        <span class="donate_txt">
           &uarr;<br>
           ～～喜欢我就点我吧～～
        </span>
        <br>
      </div>  
    <div id="donate_guide" class="donate_bar center hidden" >
        <!-- 支付宝打赏图案 -->
        <img src="/images/alipay.jpg" alt="支付宝打赏"> 
        <img src="/images/donate.jpg">
        <!-- 微信打赏图案 -->
        <img src="/images/wepay.jpg" alt="微信打赏">  
    </div>
    <script type="text/javascript">
        document.getElementById('btn_donate').onclick = function(){
            $('#donate_board').addClass('hidden');
            $('#donate_guide').removeClass('hidden');
        }
    </script>
</div>
<!-- End 添加捐赠图标 -->


  
  
  
    
<nav id="article-nav">
  
  
    <a href="/2016/05/26/LEAF-Photo/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">LEAF Photo</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
  
</article>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
    <a class="jiathis_button_twitter"></a>
    <a class="jiathis_button_plus"></a> 
    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="Concurrent-Programming-and-Synchronization" data-title="Concurrent Programming and Synchronization" data-url="http://yoursite.com/2016/06/24/Concurrent-Programming-and-Synchronization/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 Alicia Ly
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>



  </div>
</body>
</html>